non_terminal {
    program
    stmts
    stmt
    defs
    def
    var_decl var_def array_def struct_def
    func_type var_type Array_type var_types
    Array_index assign_left
    printf_arg printf_variable scanf_arg scanf_variable printf_variables scanf_variables
    if_stmt if_else_stmt while_stmt for_stmt expr func_def break_stmt continue_stmt return_stmt
    arith_expr rel_expr logical_expr assign_expr call_expr primary_expr
    binary_arith_expr unary_minus_expr unary_expr unary_back_expr unary_front_expr
    arith_op rel_op logical_binary_op assign_op unary_op
    binary_logical_expr not_expr
    BOOL_CONST_ 
    input_output_call math_call string_method_call array_method_call user_function_call
    ident_list expr_list element_list
    array_method string_method
    array_get array_insert array_push_back array_set array_size
    string_append string_copy_string string_compare_strings string_size
    input_output_printf input_output_scanf
    math_pow math_sqrt math_round math_floor math_ceiling math_sin math_cos
}

terminal {
    PLUS MINUS TIMES BY MODULO UMINUS
    GREATER LESS EQUAL_TO NOT_EQUAL_TO GREATER_EQUAL LESS_EQUAL
    PLUS_PLUS MINUS_MINUS
    PLUS_EQUALS MINUS_EQUALS TIMES_EQUALS BY_EQUALS MOD_EQUALS
    AND OR NOT
    EQUALS
    INT CHAR FLOAT DOUBLE VOID
    true false
    IF ELSE WHILE FOR BREAK CONTINUE RETURN
    CALL FUNCTION OF WITH PARAMETERS "(" ")" "{" "}" "[" "]"
    ARRAY "IN ARRAY"
    get insert push_back set get_size
    "IN STRING"
    append strcpy strcmp
    struct
    printf scanf
    pow sqrt round floor ceiling sin cos
}

define program {
    defs
}

define defs {
    list_of def
}

define stmts {
    list_of stmt
}

define stmt {
    any_of {
        if_stmt                 : "Do something if a condition is true"
        if_else_stmt            : "Do something if a condition is true, else do something else"
        while_stmt              : "Do something while a condition is true"
        for_stmt                : "Do something while a condition is true. Commonly used with a known number of iterations."
        expr(expr_stmt)         : "A single expression as a statement"
        break_stmt              : "Exit from the current loop"
        continue_stmt           : "Continue to the next iteration of the current loop"
        return_stmt             : "Return an expression as the result of the current function"
    }
}

define func_type {
    any_of {
        INT                     : "FUNCTION returns int "
        CHAR                    : "FUNCTION returns char "
        FLOAT                   : "FUNCTION returns float "
        DOUBLE                  : "FUNCTION returns double "
        VOID                    : "FUNCTION returns nothing "
    }
}

define var_type {
    any_of {
        INT                     : "Int variable definition"
        CHAR                    : "Char variable definition"
        FLOAT                   : "Float variable definition"
        DOUBLE                  : "Double variable definition"
    }
}

define Array_type {
    any_of {
        INT                     : "Array of ints"
        CHAR                    : "Array of chars"
        FLOAT                   : "Array of floats"
        DOUBLE                  : "Array of doubles"
    }
}

define def {
    any_of {
        stmt
        var_decl                : "Variable or Array declaration with type and name"
        struct_def              : "Struct declaration with name and fields"
        func_def                : "Define reusable code as a function"
    }
}

define expr {
    any_of {
        arith_expr              : "Perform a mathematic operation"
        rel_expr                : "An operator that compares the two operands and returns true or false"
        logical_expr            : "An expression that evaluates to true or false"
        assign_expr             : "Set a variable's value"
        call_expr               : "Call a user-defined or built-in function/method"
        primary_expr            : "An identifier or a constant"
    }
}

define arith_expr {
    any_of {
        binary_arith_expr       : "An arithmetic expression with two operands"
        unary_minus_expr        : "Negates the value of its operand"
        unary_expr              : "An arithmetic expression with one operand"
    }
}

define unary_expr {
    any_of {
        unary_back_expr         : "An arithmetic expression with one back-operator "
        unary_front_expr        : "An arithmetic expression with one front-operator"
    }
}

define unary_back_expr {
    unary_op                    : "An unary operator (e.g. ++, --)"
    expr                        : "The second operand"
}

define unary_front_expr {
    expr                        : "The first operand" 
    unary_op                    : "An unary operator (e.g. ++, --)"
}

define unary_op {
    any_of {
        PLUS_PLUS("++")         : "Increment by one"
        MINUS_MINUS("- -")      : "Decrement by one"
    }
}

define unary_minus_expr {
    UMINUS("-")                     :"The first operand"
    expr                            : "The second operand"
}

define binary_arith_expr {
    expr                            : "The first operand"
    arith_op                        : "An arithmetic operator (e.g. +, -)"
    expr                            : "The second operand"
}

define arith_op {
    any_of {
        PLUS("+")                   : "Performs addition"
        MINUS("-")                  : "Performs subtraction"
        TIMES("*")                  : "Performs multipliction"
        BY("/")                     : "Performs division"
        MODULO("%")                 : "Performs the modulo operation"
    }
}

define rel_expr {
    expr                            : "The first operand"
    rel_op                          : "A comparison operator that returns true or false (e.g <, >)"
    expr                            : "The second operand"
}

define rel_op {
    any_of {
        GREATER(">")                : "Returns true if the first operand is greater than the second operand, else returns false"
        LESS("<")                   : "Returns true if the first operand is less than the second operand, else returns false"
        EQUAL_TO("==")              : "Returns true if the first operand is equal to the second operand, else returns false"
        NOT_EQUAL_TO("!=")          : "Returns true if the first operand not equal to the second operand, else returns false"
        GREATER_EQUAL(">=")         : "Returns true if the first operand is greater than or equal to the second operand, else returns false"
        LESS_EQUAL("<=")            : "Returns true if the first operand is less than or equal to the second operand, else returns false"    
    }
}

define logical_expr {
    any_of {
        binary_logical_expr     : "Performs a binary operation with two operands"
        not_expr                : "Performs logical negation. True becomes false and false becomes true"
    }
}

define binary_logical_expr {
    expr                        : "The first operand"
    logical_binary_op           : "Performs a binary operation with two operands"
    expr                        : "The second operand"
}

define logical_binary_op {
    any_of {
        AND("&&")                : "Returns true if both operands are true, else returns false"
        OR("||")                 : "Returns true if either operand is true, else returns false"
    }
}

define not_expr {
    NOT("!")                     : "Returns true if the operand is false, else returns false"
    expr                         : "The operand"
}

define primary_expr {
    any_of {
        IDENT                   : "An identifier starting with _ or a uppercase/lowercase letter following by 0 or more characters that can be _ numbers lowercase/uppercase letters with type"
        INT_CONST               : "An integer is a positive, zero, or negative number that can be written without a fractional component (i.e. no decimal point places)"
        FLOAT_CONST             : "A floating-point number is a rational number (i.e. includes numbers with decimal point places"
        CHAR_CONST              : "One single character"
        STRING_CONST            : "Any sequence of characters or the empty sequence"
        BOOL_CONST_             : "One of true or false"
    }
}

define var_decl {
    any_of {
        var_def                  : "Variable declaration with type and name"
        array_def                : "Array declaration with type, name and size"
    }
}

define var_def {
    var_type IDENT(VARIABLE_NAME)          
}

define struct_def {
    IDENT
}

define BOOL_CONST_ {
    any_of {
        true
        false
    }
}

define call_expr {
    any_of {
        input_output_call       : "Use a built-in input/output function"
        math_call               : "Use a built-in math function"
        string_method_call      : "Use a built-in string method"
        user_function_call      : "Use a user-defined function"
    }
}

define array_def {
    Array_type IDENT(ARRAY_NAME) "[" INT_CONST(ARRAY_SIZE) "]"    : "Array declaration with type, name and size"
}

define element_list {
    list_of expr(element)
}

define assign_expr {
    assign_left assign_op expr            
}
define assign_left {
    any_of{
        primary_expr            :"Assign values in primary expr"
        Array_index             :"Assign values in array"
    }   
}

define Array_index{
    IDENT(ARRAY_NAME) "[" INT_CONST "]"
}

define assign_op {
    any_of {
        EQUALS("=")                : "Assigns values from right side operands to left side operand"
        PLUS_EQUALS("+=")          : "Adds the right operand to the left operand and assign the result to the left operand"
        MINUS_EQUALS("-=")         : "Subtracts the right operand from the left operand and assigns the result to the left operand"
        TIMES_EQUALS("*=")         : "Multiplies the right operand with the left operand and assigns the result to the left operand"
        BY_EQUALS("/=")            : "Divides the left operand with the right operand and assigns the result to the left operand"
        MOD_EQUALS("%=")           : "Returns true if the first operand is less than or equal to the second operand, else returns false"    
    }
}

define func_def {
   func_type IDENT(NAME) WITH PARAMETERS ident_list "{" stmts  "}"
}

define struct_def {
    struct IDENT(STRUCT_NAME) "{" ident_list "}"  
}

define break_stmt {
    BREAK
}

define continue_stmt {
    CONTINUE
}

define return_stmt {
    RETURN
    expr
}

define user_function_call {
    IDENT("FUNCTION NAME") WITH expr_list
}

define string_method_call {
    "IN STRING" expr("string") CALL string_method
}

define string_method {
    any_of {
        string_append(append)                           : "Get a new string with the argument string added to the end (suffix) of the original"
        string_copy_string(copy_string)                 : "Can copy the content of a string to another"
        string_compare_strings(compare_string)          : "Can compare two strings"
        string_size(get_size)                           : "Get the count of characters contained in the string"
    }
}

define string_append {
    append WITH expr("string")
}

define string_copy_string {
    strcpy WITH expr("string_dest") expr("string_source")
}

define string_compare_strings {
    strcmp WITH expr("string1") expr("string2")
}

define string_size {
    get_size
}

define input_output_call {
    any_of {
        input_output_printf(printf)       : "Print the value of the given expression (text, number etc.)"
        input_output_scanf(scanf)         : "Prompt the user with a text message and get user-input"
    }
}

define input_output_printf {
    CALL printf WITH printf_arg
}

define input_output_scanf {
    CALL scanf WITH scanf_arg
}

define printf_arg {
    any_of{
        printf_variable                    :"Print variable in output screen"
        STRING_CONST                       :"Print text in output screen"
    }
}

define printf_variable {
    list_of printf_variables 
}

define printf_variables {
    var_type IDENT
}

define scanf_arg {
    list_of scanf_variables   
}

define scanf_variables {
   var_type IDENT
}

define var_types {
    list_of var_type 
}

define math_call {
    any_of {
        math_pow(pow)                       : "Raise a number into a power"
        math_sqrt(sqrt)                     : "Get the square root of a number"
        math_round(round)                   : "Get the nearset integer to the given number"
        math_floor(floor)                   : "Get the greatest integer less than or equal to the given number"
        math_ceiling(ceiling)               : "Get the least integer greater than or equal to the given number"
        math_sin(sin)                       : "Get the sin of the given angle in degrees"
        math_cos(cos)                       : "Get the cos of the given angle in degrees"
    }
}

define math_pow {
    CALL pow WITH expr(number) expr(exponent)
}

define math_sqrt {
    CALL sqrt WITH expr(number)
}

define math_round {
    CALL round WITH expr(number)
}

define math_floor {
    CALL floor WITH expr(number)
}

define math_ceiling {
    CALL ceiling WITH expr(number)
}

define math_sin {
    CALL sin WITH expr(number)
}

define math_cos {
    CALL cos WITH expr(number)
}

define if_stmt {
    IF expr(condition_expr) stmts(if_part)
}

define if_else_stmt {
    IF expr(condition_expr) stmts(if_part) ELSE stmts(else_part)
}

define while_stmt {
    WHILE expr(condition_expr) stmts(while_part)
}

define for_stmt {
    FOR
    expr(initialization_expr)
    expr(condition_expr)
    expr(step_expr)
    stmts(for_part)
}

define ident_list {
    list_of var_decl
}

define expr_list {
    list_of expr(arg)
}